# 3A 原則背後的思維是什麼？

當我們使用 3A 原則來實現測試案例的時候，可以發現測試案例關注的東西只有三個，分別為：
1. input
2. 受測方法
3. output

也就是說，測試案例只關心丟了哪些 `Input` 應該輸出哪些 `Output` ，並不在乎 **受測方法的內部做了哪些事**。

這個現象體現了物件導向的 `封裝` 特性，受測物件將 **複雜的實作內容** 封裝到物件內部，只暴露外部的方法（Public method）供測試案例調用。

換句乎話說，若以測試案例的角度來看受測物件，測試案例只能看見 **受測物件的外部方法**。

## 「測試案例只能看見受測物件的外部方法」可以帶來什麼好處？

### 1. 促使開發人員設計更精簡易懂的外部方法

當開發人員在撰寫測試案例時，開發人員的視角等同於 `受測物件的使用者`，只能看見受測物件的外部。

以一個使用者的角度來說，我們一定會希望物件越容易使用越好！

我們可以用「時間格式轉換」的範例來看看，有哪一種設計比較討喜：

#### 沒有良好設計的物件

```
// 時間格式轉換
var now = new Date();  
var year = now.getFullYear();  
var month = ("0" + (now.getMonth() + 1)).slice(-2);  
var day = ("0" + (now.getDate() + 1)).slice(-2);  
var hour = ("0" + (now.getHours() )).slice(-2);  
var minute = ("0" + now.getMinutes() ).slice(-2);  
var second = ("0" + now.getSeconds() ).slice(-2);  
year + '/' + month + '/' + day + ' ' + hour + ':' + minute+ ':' + second;
```

#### 封裝良好且容易使用的物件

```
moment().format('YYYY/MM/DD HH:mm:ss');
```

大家應該都覺得 `moment().format()` 比較討喜吧！

因此，身為開發人員應該時常思考「**如何盡可能地把複雜的實作內容封裝進物件內部，並保持物件外部的可讀性**」。

除了可讀性提昇以外，當一個物件的外部的方法越少越精簡，也會越容易被測試。

### 2. 開發人員在 `不破壞外部方法的結構` 下，可以隨時重構物件內部的程式碼，提升程式碼的品質。

外部方法的結構，其實稱為 **方法簽名（Method Signature）**，一個方法簽名包含：

1. 方法的名稱
2. 方法的參數（包含型別）
3. 方法的返回值

```
public function formatTimestamp(string $format, int $timestamp) : string

- 方法名稱為：formatTimestamp 
- 方法參數為：$format, $timestamp
- 方法的返回值：string
```

由於測試案例只會與物件的外部方法互動，若針對物件內部的重構沒有修改到 **方法簽名**，對測試案例來說都像是沒有變動過。

如此一來，我們就能確保物件內部的重構不會牽一髮動全身改壞系統功能。  
就算真的修改了 **方法簽名** 的結構，也會因為執行測試案例而馬上發現有功能壞掉了，不會拖延到讓功能上線才發現。

另外，我們在設計 **方法簽名** 時，一定要考慮到未來的維護性，若 `方法簽名設計得不夠穩定，則被修改的頻率會變高` 。

```
program to interfaces not implementations
```
這句話就是在說，當我們撰寫程式時，一定要關注在物件的外部封裝，而不是內部的實作內容。

因為物件的外部封裝為設計不夠妥當時，新需求一來就很容易需要改寫物件的外部封裝，導致全系統有用到這個物件的方法都要一起被異動（牽一髮動全身）。
